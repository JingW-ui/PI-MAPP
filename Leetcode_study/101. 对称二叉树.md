好的，我们先从**题目理解**开始，然后一步步给出 **一般解法 → 进阶优化 → 面试写法 → 常见问题**，并完善代码、指出可能的问题。

---

## 1. 题目理解

**101. 对称二叉树**  
给定一个二叉树，检查它是否是镜像对称的。  
即：树的左子树和右子树互为镜像。

**示例**  
```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```
这是对称的。

```
    1
   / \
  2   2
   \   \
   3    3
```
这不是对称的。

---

## 2. 一般解法（递归）

**思路**  
对称比较：  
- 根节点相同  
- 左子树的左节点 vs 右子树的右节点  
- 左子树的右节点 vs 右子树的左节点  

递归函数 `isMirror(left, right)` 判断两棵树是否镜像。

**Python 代码（基础递归）**

```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root:
            return True
        return self.isMirror(root.left, root.right)
    
    def isMirror(self, left, right):
        # 两个都为空
        if not left and not right:
            return True
        # 一个为空，一个不为空
        if not left or not right:
            return False
        # 值相等，并且子树镜像
        return (left.val == right.val and 
                self.isMirror(left.left, right.right) and 
                self.isMirror(left.right, right.left))
```

**问题 & 注意点**  
- 空树是对称的（`root` 为 `None` 时返回 `True`）。  
- 递归终止条件要写全：两个空 → True；一个空一个非空 → False。  
- 不要漏掉 `left.val == right.val` 的判断。

---

## 3. 进阶解法（迭代 BFS/DFS）

### 3.1 迭代（BFS 层序遍历 + 双队列）

用队列同时存储左右子树对应位置的节点，每次取出两个比较。

```python
from collections import deque

class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root:
            return True
        
        queue = deque()
        queue.append(root.left)
        queue.append(root.right)
        
        while queue:
            left = queue.popleft()
            right = queue.popleft()
            
            # 两个都为空，继续
            if not left and not right:
                continue
            # 一个为空，不对称
            if not left or not right:
                return False
            # 值不等，不对称
            if left.val != right.val:
                return False
            
            # 按顺序加入下一层：左左、右右、左右、右左
            queue.append(left.left)
            queue.append(right.right)
            queue.append(left.right)
            queue.append(right.left)
        
        return True
```

**问题**  
- 队列顺序必须严格对应镜像位置：`(left.left, right.right)` 和 `(left.right, right.left)` 成对入队。  
- 如果顺序错，会误判。

---

### 3.2 迭代（DFS 栈）

思路和递归类似，用栈模拟递归调用。

```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root:
            return True
        
        stack = [(root.left, root.right)]
        
        while stack:
            left, right = stack.pop()
            
            if not left and not right:
                continue
            if not left or not right:
                return False
            if left.val != right.val:
                return False
            
            stack.append((left.left, right.right))
            stack.append((left.right, right.left))
        
        return True
```

---

## 4. 面试解法

面试时推荐 **递归**（简洁易懂）或 **BFS 迭代**（避免递归深度问题）。  
要能说明：

1. **递归的终止条件**（两个空、一个空、值不等）。
2. **时间复杂度**：O(n)，每个节点访问一次。  
   **空间复杂度**：递归 O(h)，h 为树高；迭代 O(n)。
3. **边界情况**：空树、单节点、只有左子树或右子树等。
4. 可以画图解释镜像比较的过程。

---

## 5. 常见问题

1. **空树算不算对称？**  
   算，`root` 为 `None` 时返回 `True`。

2. **只有一个节点是否对称？**  
   是，因为左右子树都为空。

3. **递归深度过大怎么办？**  
   改用迭代 BFS/DFS，避免栈溢出。

4. **迭代时入队顺序错误**  
   必须成对入队 `(left.left, right.right)` 和 `(left.right, right.left)`，否则逻辑错误。

5. **混淆“对称”与“相同”**  
   对称是镜像比较，不是两棵相同的树。

---

## 6. 代码完善与问题指出

假设你之前给出的代码可能有以下问题（常见错误）：

```python
# 错误示例
def isSymmetric(self, root):
    if not root:
        return True
    return self.isMirror(root.left, root.right)

def isMirror(self, left, right):
    if left == None and right == None:
        return True
    if left.val == right.val:  # 这里可能 left 或 right 为 None，直接 .val 会报错
        return self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)
    else:
        return False
```

**问题**：
1. 没有检查 `left` 或 `right` 为 `None` 的情况就直接 `.val`，会引发 `AttributeError`。
2. 缺少一个为空另一个不为空的判断。
3. 递归调用前应先判断结构对称再判断值。

**修正后**就是我们上面给出的基础递归代码。

---

## 7. 总结

| 方法 | 优点 | 缺点 |
|------|------|------|
| 递归 | 代码简洁，易理解 | 深度大时可能栈溢出 |
| BFS 迭代 | 无递归深度限制，适合大树 | 代码稍长，需维护队列顺序 |
| DFS 迭代 | 空间可能比 BFS 好 | 逻辑稍绕 |

面试时先写递归，再提迭代优化，展示全面性。