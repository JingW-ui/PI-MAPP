这道题是 **LeetCode 21. 合并两个有序链表（Merge Two Sorted Lists）**，是链表操作的基础题，也是面试高频题。下面从 **一般解法 → 进阶解法 → 面试策略 → 常见误区与扩展** 全面解析。

---

## ✅ 一、题目回顾

- 输入：两个**升序**单链表 `l1` 和 `l2`
- 要求：合并为一个**升序链表**
- 规则：**不能创建新节点**（通常理解为“复用原节点”，即拼接）
- 返回：合并后的链表头节点

> 示例：  
> `l1 = [1→2→4]`, `l2 = [1→3→4]` → `[1→1→2→3→4→4]`

---

## 🟢 二、一般解法（迭代 + 虚拟头节点）

### 🔑 核心思想：
- 使用**双指针**分别遍历 `l1` 和 `l2`
- 每次选择较小的节点接到结果链表
- 使用**虚拟头节点（dummy node）** 简化边界处理

### ✅ Python 实现：
```python
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)  # 虚拟头节点
        cur = dummy
        
        while l1 and l2:
            if l1.val <= l2.val:
                cur.next = l1
                l1 = l1.next
            else:
                cur.next = l2
                l2 = l2.next
            cur = cur.next
        
        # 接上剩余部分（其中一个已为空）
        cur.next = l1 or l2
        
        return dummy.next
```

### ⏱️ 复杂度：
- 时间：O(m + n)
- 空间：O(1)（只用指针，未创建新节点值）

### ✅ 优点：
- 直观、高效、空间最优
- 虚拟头节点避免处理“第一个节点”的特殊情况

---

## 🔵 三、进阶解法（递归）

### 🔑 思路：
- **递归定义**：合并 `l1` 和 `l2` = 较小头节点 + 合并剩余部分
- 基线条件：任一链表为空，返回另一个

### ✅ Python 实现：
```python
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        if not l1:
            return l2
        if not l2:
            return l1
        
        if l1.val <= l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2
```

### ⏱️ 复杂度：
- 时间：O(m + n)
- 空间：O(m + n)（递归栈深度）

### ✅ 优点：
- 代码极简，体现递归思维
- 逻辑清晰，数学归纳感强

### ❌ 缺点：
- 链表很长时可能栈溢出（Python 默认递归深度 ~1000）
- 空间开销大

> 💡 在支持尾递归优化的语言中更优，但 Python 不支持。

---

## 💼 四、面试解法建议

### 推荐回答流程：

1. **Clarify**（澄清）：
   - “是否可以修改原链表？” → 通常允许（拼接即修改 `next` 指针）
   - “空链表如何处理？” → 返回另一个

2. **提出两种思路**：
   - 方法1：迭代（推荐，空间安全）
   - 方法2：递归（简洁，但有栈风险）

3. **优先实现迭代解法**（面试官更看重健壮性）：
   - 强调使用 `dummy` 节点
   - 处理剩余链表用 `l1 or l2`

4. **测试用例**：
   - 正常：`[1,2,4] + [1,3,4]` → `[1,1,2,3,4,4]`
   - 一边为空：`[] + [0]` → `[0]`
   - 都为空：`[] + []` → `[]`
   - 交错：`[1,3,5] + [2,4,6]` → `[1,2,3,4,5,6]`

---

## ⚠️ 五、常见错误 & 陷阱

| 错误 | 说明 |
|------|------|
| **忘记处理剩余链表** | 循环结束后，直接返回，漏掉 `l1` 或 `l2` 的尾巴 |
| **手动逐个拼接剩余节点** | 不必要！直接 `cur.next = l1 or l2` 即可 |
| **创建新节点** | 题目要求“拼接”，应复用原节点（除非明确允许新建）|
| **递归不写基线条件** | 导致无限递归 |

---

## 🔁 六、常见 Follow-up 问题

### Q1：合并 k 个有序链表？（LeetCode 23）
- 解法1：两两合并（O(kN)）
- 解法2：**最小堆（优先队列）**（O(N log k)）
- 解法3：分治合并（O(N log k)）

### Q2：如果链表是**降序**的，怎么合并？
- 反向比较（`>=`），或先反转再合并再反转

### Q3：能否原地合并到 `l1` 中？
- 可以，但需小心指针断裂，通常不如新建 `dummy` 清晰

### Q4：如果内存受限，不能用递归怎么办？
- 必须用迭代解法（这也是为什么迭代是首选）

---

## 🧠 七、总结对比

| 方法 | 时间 | 空间 | 是否修改原链表 | 面试推荐 |
|------|------|------|------------------|--------|
| 迭代（dummy） | O(m+n) | O(1) | 是（拼接） | ✅✅ 强烈推荐 |
| 递归 | O(m+n) | O(m+n) | 是 | ✅ 可作为补充 |

---

## ✅ 最终推荐代码（面试版）

```python
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode()
        cur = dummy
        
        while list1 and list2:
            if list1.val <= list2.val:
                cur.next = list1
                list1 = list1.next
            else:
                cur.next = list2
                list2 = list2.next
            cur = cur.next
        
        cur.next = list1 or list2
        return dummy.next
```

> 💡 这段代码：
> - 使用 `dummy` 避免头节点特殊处理
> - 用 `or` 简洁处理剩余链表
> - 空间 O(1)，时间最优，无栈风险

---

掌握这道题，你就掌握了**链表双指针**和**虚拟头节点**两大核心技巧，为后续如「合并K个链表」「链表排序」等难题打下坚实基础！


讲解一下为啥返回的是
 return dummy.next
以及可否省去这一步
        cur = dummy

非常好的问题！这是理解「虚拟头节点（dummy node）」技巧的关键。我们来**深入讲解为什么返回 `dummy.next`，以及 `cur = dummy` 是否可以省略**。

---

## 🎯 一、为什么需要 `dummy` 节点？

### ❓ 问题：合并后的链表**头节点不确定**
- 可能是 `l1` 的第一个节点（如果 `l1.val <= l2.val`）
- 也可能是 `l2` 的第一个节点
- 在遍历过程中，我们不断移动指针，**无法提前知道最终的头是谁**

### 💡 解决方案：引入一个**假的头节点 `dummy`**
- 它不存真实数据（比如 `val=0` 或任意值）
- 它的唯一作用是：**作为结果链表的“锚点”**
- 真正的头节点会成为 `dummy.next`

---

## 🔍 二、代码执行过程演示

假设：
```python
l1 = [1 → 2 → 4]
l2 = [1 → 3 → 4]
```

### 步骤：

1. **初始化**：
   ```python
   dummy = ListNode(0)  # dummy → ?
   cur = dummy          # cur 指向 dummy
   ```

2. **第一次循环**：
   - `l1.val (1) <= l2.val (1)` → 选 `l1`
   - `cur.next = l1` → `dummy → 1`
   - `cur = cur.next` → `cur` 现在指向 `1`
   - `l1 = l1.next` → `l1` 指向 `2`

3. **后续步骤**：
   - `cur` 不断向后移动，拼接节点
   - `dummy` 始终不动！

4. **最终状态**：
   ```
   dummy → 1 → 1 → 2 → 3 → 4 → 4
            ↑
          真实头节点
   ```

✅ 所以：**`dummy.next` 就是合并后链表的真实头节点**

---

## ❌ 三、如果不使用 `dummy`，会怎样？

你可以尝试不用 `dummy`，但必须**手动处理第一个节点**：

```python
def mergeTwoLists(l1, l2):
    if not l1:
        return l2
    if not l2:
        return l1
    
    # 先确定头节点
    if l1.val <= l2.val:
        head = l1
        l1 = l1.next
    else:
        head = l2
        l2 = l2.next
    
    cur = head  # 从真实头开始
    while l1 and l2:
        if l1.val <= l2.val:
            cur.next = l1
            l1 = l1.next
        else:
            cur.next = l2
            l2 = l2.next
        cur = cur.next
    
    cur.next = l1 or l2
    return head
```

### ⚠️ 问题：
- 代码更长、更复杂
- 需要提前判断头节点
- 容易漏掉边界情况（如一个为空）

> ✅ **`dummy` 的价值：统一处理逻辑，避免特殊 case**

---

## ❓ 四、`cur = dummy` 能省吗？

**不能省！** 原因如下：

### 目的：`cur` 是**移动的指针**，用于构建链表  
`dummy` 是**固定的锚点**，用于记住头

如果你写成：
```python
dummy = ListNode()
# 没有 cur = dummy
while ...:
    dummy.next = ...  # ❌ 错误！
    dummy = dummy.next
```

那么：
- `dummy` 会不断后移
- 最后你**丢失了链表的起点**
- 无法返回正确结果

### ✅ 正确分工：
| 变量 | 角色 |
|------|------|
| `dummy` | 固定不动，记住整个结果链表的入口 |
| `cur` | 移动指针，负责“施工”——不断接新节点 |

> 💡 类比：`dummy` 是工地大门，`cur` 是工人。工人到处跑干活，但大门始终在原地，方便你最后找到工地。

---

## ✅ 五、总结

| 问题 | 回答 |
|------|------|
| **为什么返回 `dummy.next`？** | 因为 `dummy` 是假头，真实链表从 `dummy.next` 开始 |
| **能否不用 `dummy`？** | 可以，但代码更复杂，易出错；**不推荐** |
| **`cur = dummy` 能省吗？** | ❌ 不能！否则会丢失链表头 |
| **`dummy` 占用额外空间吗？** | 是，但只是 O(1) 一个节点，完全可接受 |

---

## 💡 记忆口诀

> **“建个假头当锚点，工人（cur）干活它不动；最后返回假头.next，链表完整不落空。”**

这个技巧在**所有需要构建新链表**的题目中都非常有用（如反转链表、删除节点、合并链表等），务必掌握！