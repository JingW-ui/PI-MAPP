这道题是 LeetCode 第 104 题：**二叉树的最大深度（Maximum Depth of Binary Tree）**。题目要求返回从根节点到最远叶子节点的路径上所包含的节点数（注意是“节点数”，不是边数）。

下面我们从 **一般解法 → 进阶解法 → 面试解法 → 常见问题** 四个维度来系统讲解。

---

## 一、一般解法（递归 DFS）

### 思路
- 如果当前节点为空，深度为 0。
- 否则，分别求左右子树的最大深度，取较大值 +1（当前节点）。

### 代码（Python）
```python
def maxDepth(root):
    if not root:
        return 0
    left = maxDepth(root.left)
    right = maxDepth(root.right)
    return max(left, right) + 1
```

### 时间/空间复杂度
- 时间：O(n)，每个节点访问一次。
- 空间：O(h)，h 是树的高度（递归栈深度），最坏 O(n)（退化成链表），最好 O(log n)（平衡树）。

> ✅ 优点：简洁、直观，适合初学者理解递归。

---

## 二、进阶解法（迭代 BFS / 层序遍历）

### 思路
- 使用队列进行层序遍历（BFS）。
- 每遍历完一层，深度 +1。
- 当队列为空时，返回层数。

### 代码（Python）
```python
from collections import deque

def maxDepth(root):
    if not root:
        return 0
    queue = deque([root])
    depth = 0
    while queue:
        depth += 1
        for _ in range(len(queue)):  # 处理当前层所有节点
            node = queue.popleft()
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
    return depth
```

### 时间/空间复杂度
- 时间：O(n)
- 空间：O(w)，w 是树的最大宽度（最坏 O(n)）

> ✅ 优点：避免递归栈溢出，适合处理非常深的树（虽然实际中很少遇到）。

---

## 三、面试解法（展示全面思维）

在面试中，不仅要写出正确代码，还要：

### 1. **明确边界条件**
- 空树 → 返回 0
- 只有根节点 → 返回 1

### 2. **讨论两种主流方法**
- **DFS（递归）**：代码简洁，但可能栈溢出（对极深树）。
- **BFS（迭代）**：更安全，但空间开销可能更大（宽树）。

> 💡 面试官常问：“哪种方法更好？”  
> 回答：**通常 DFS 更常用**，因为代码简洁且平均空间更优；但如果树极度不平衡（如链表），且语言不支持尾递归优化，BFS 更稳健。

### 3. **扩展思考（加分项）**
- 如果是 N 叉树？→ 类似，遍历所有 children。
- 如果要返回**最大深度对应的路径**？→ DFS + 回溯记录路径。
- 如果节点带权重，求**最大加权深度**？→ 修改递归逻辑，传递累计权重。

### 4. **手写清晰、命名规范**
```python
def maxDepth(self, root: Optional[TreeNode]) -> int:
    if not root:
        return 0
    return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
```

> ✅ 面试建议：先写递归解法（快且准），再主动提出 BFS 方案，展示工程思维。

---

## 四、常见问题（FAQ）

### Q1：深度 vs 高度？有什么区别？
- **深度（Depth）**：从根到当前节点的路径长度（根深度=1 或 0，本题按节点数算，根深度=1）。
- **高度（Height）**：从当前节点到最远叶子的路径长度（叶子高度=1）。
- 对整棵树而言，**最大深度 = 根节点的高度**。

> 本题本质是求根节点的高度（按节点数计）。

---

### Q2：为什么不是 `min(left, right) + 1`？
- 因为题目要求“**最远**叶子节点”，所以取 **max**。
- 若求最小深度（LeetCode 111），才用 min（但需注意单侧子树为空的情况）。

---

### Q3：能否用 Morris 遍历实现 O(1) 空间？
- 理论上可以，但**无法直接用于求深度**，因为 Morris 遍历破坏/恢复树结构，难以维护层级信息。
- 实际面试中**不要强行用 Morris**，会显得炫技且易错。

---

### Q4：如果树非常大（百万节点），怎么办？
- 递归可能导致栈溢出 → 改用 BFS（迭代）。
- 或使用显式栈模拟 DFS（非递归 DFS）：
  ```python
  def maxDepth(root):
      if not root: return 0
      stack = [(root, 1)]
      max_depth = 0
      while stack:
          node, depth = stack.pop()
          max_depth = max(max_depth, depth)
          if node.left: stack.append((node.left, depth + 1))
          if node.right: stack.append((node.right, depth + 1))
      return max_depth
  ```

---

## 总结

| 方法       | 类型   | 优点                     | 缺点               |
|------------|--------|--------------------------|--------------------|
| 递归 DFS   | 一般   | 简洁、易理解             | 深树可能栈溢出     |
| 迭代 BFS   | 进阶   | 无递归、稳定             | 宽树内存占用大     |
| 非递归 DFS | 工程   | 控制栈、灵活             | 代码稍复杂         |


> ✅ **面试推荐策略**：  
> 1. 快速写出递归解法；  
> 2. 主动分析时空复杂度；  
> 3. 提出 BFS 作为备选；  
> 4. 讨论边界与扩展场景。

这道题看似简单，却是考察**递归思维、树遍历、工程权衡**的经典入口题。掌握它，就掌握了树类问题的钥匙 🔑。

当然可以！如果你是**编程小白**，不用担心，我会用最通俗、最详细的方式，一步一步带你理解这道题的两种主流解法：**递归（DFS）** 和 **层序遍历（BFS）**。

---

## 🌳 题目回顾

> 给定一个二叉树 `root`，返回它的**最大深度**。  
> **最大深度** = 从根节点到最远叶子节点的路径上**包含的节点个数**。

举个例子：

```
        3
       / \
      9  20
        /  \
       15   7
```

- 路径 `3 → 20 → 7` 有 3 个节点。
- 所以最大深度是 **3**。

> ✅ 注意：不是边的数量，而是**节点的数量**！

---

## 解法一：递归（DFS）——“分而治之”的思路

### 🧠 核心思想（用人话讲）：
> “一棵树的最大深度 = 它左右子树中更深的那个 + 1（自己这个节点）”

比如：
- 左子树最深能走到第 2 层，
- 右子树最深能走到第 3 层，
- 那么整棵树就是 `max(2, 3) + 1 = 4` 层。

如果树是空的（`None`），那深度就是 0。

这就叫**递归**：大问题拆成小问题，小问题和大问题结构一样！

---

### 🔍 代码逐行解释（Python）

```python
def maxDepth(root):
    # 第一步：如果当前节点是空的（比如走到叶子下面了）
    if not root:
        return 0          # 空树深度为 0

    # 第二步：递归计算左子树的最大深度
    left_depth = maxDepth(root.left)

    # 第三步：递归计算右子树的最大深度
    right_depth = maxDepth(root.right)

    # 第四步：取左右子树中更大的那个，再加 1（加上当前这个节点）
    return max(left_depth, right_depth) + 1
```

### 🎯 举个具体例子走一遍

树结构：
```
    A
   / \
  B   C
     /
    D
```

调用过程（像剥洋葱）：

1. `maxDepth(A)`  
   → 调用 `maxDepth(B)` 和 `maxDepth(C)`

2. `maxDepth(B)`  
   → B 的左右都是空 → 返回 `max(0,0)+1 = 1`

3. `maxDepth(C)`  
   → 调用 `maxDepth(D)` 和 `maxDepth(None)`

4. `maxDepth(D)`  
   → D 的左右都空 → 返回 1

5. `maxDepth(C)` 得到：`max(1, 0) + 1 = 2`

6. 回到 `maxDepth(A)`：`max(1, 2) + 1 = 3`

✅ 最终结果：3 —— 正确！

> 💡 小白提示：递归就像“问别人”，你问左孩子“你有多深？”，他再去问他自己的孩子……直到问到空（没人了），就回答 0，然后一层层往回报数。

---

## 解法二：层序遍历（BFS）——“一层一层数”

### 🧠 核心思想（用人话讲）：
> 我们像“剥洋葱”一样，一层一层地处理树：
> - 第 1 层：只有根节点 → 深度 = 1
> - 第 2 层：根的所有孩子 → 深度 = 2
> - ……
> - 数到没有下一层为止，总共数了几层，就是最大深度。

这需要一个“队伍”（队列）来记住当前层有哪些节点。

---

### 🔍 代码逐行解释（Python）

```python
from collections import deque  # 导入“双端队列”，用来当队伍用

def maxDepth(root):
    # 如果树是空的，直接返回 0
    if not root:
        return 0

    # 创建一个队伍，先把根节点放进去
    queue = deque([root])
    
    depth = 0  # 当前深度，从 0 开始数

    # 只要队伍里还有人（还有节点没处理），就继续
    while queue:
        depth += 1  # 进入新的一层，深度 +1

        # 把当前这一层的所有节点都处理完
        # 注意：len(queue) 是“当前层”的节点数量
        for _ in range(len(queue)):
            node = queue.popleft()  # 从队伍前面拿出一个节点

            # 把它的左孩子（如果有）加入队伍
            if node.left:
                queue.append(node.left)

            # 把它的右孩子（如果有）加入队伍
            if node.right:
                queue.append(node.right)

    return depth
```

### 🎯 同样用上面的例子走一遍

树：
```
    A
   / \
  B   C
     /
    D
```

执行过程：

1. 初始：`queue = [A]`, `depth = 0`

2. 进入 while 循环：
   - `depth = 1`
   - 当前层有 1 个节点（A）
   - 处理 A：把 B 和 C 加入队列 → `queue = [B, C]`

3. 下一轮循环：
   - `depth = 2`
   - 当前层有 2 个节点（B, C）
   - 处理 B：没孩子，不加
   - 处理 C：有左孩子 D → 加入 → `queue = [D]`

4. 下一轮循环：
   - `depth = 3`
   - 当前层有 1 个节点（D）
   - 处理 D：没孩子 → `queue = []`

5. 队列空了，退出循环 → 返回 `depth = 3`

✅ 结果正确！

> 💡 小白提示：BFS 就像“按年级分班”——先处理一年级所有学生，再处理二年级……每升一个年级，层数+1。

---

## 🆚 两种方法对比（小白友好版）

| 特点 | 递归（DFS） | 层序遍历（BFS） |
|------|-------------|------------------|
| **代码长度** | 很短（4 行） | 稍长（8 行） |
| **思维方式** | “分任务给别人” | “一层一层数” |
| **适合谁** | 喜欢数学/逻辑的人 | 喜欢模拟过程的人 |
| **内存使用** | 用“函数调用栈”（可能爆掉，但一般没事） | 用“队列”存节点（宽树会吃内存） |
| **面试推荐** | ✅ 先写这个！ | ✅ 写完可以说：“我还可以用 BFS 做” |

---

## ❓ 小白常见疑问

### Q：为什么递归不会无限循环？
A：因为每次都会往**子节点**走，最终会遇到 `None`（空），这时就返回 0，不再递归了。就像走到树的“尽头”就停。

### Q：`deque` 是什么？不能用 list 吗？
A：可以用 `list`，但 `list.pop(0)` 删除第一个元素很慢（要移动后面所有元素）。`deque.popleft()` 是专门优化过的，快很多。不过做题时用 list 也能过，只是不专业。

### Q：深度是从 0 开始还是 1 开始？
A：题目说“节点数”，所以：
- 空树 → 0 个节点 → 深度 0
- 只有根 → 1 个节点 → 深度 1  
我们的代码完全符合这个定义！

---

## ✅ 总结（给小白的行动建议）

1. **先理解递归版本**：它短、美、常用。
2. **手动画一个小树**，按代码走一遍，感受“递归是怎么回来的”。
3. **再看 BFS 版本**：想象自己在“数楼层”。
4. **两种都敲一遍代码**，跑几个例子（比如空树、单节点、斜树）。
5. 面试时：**先写递归**，再说“也可以用 BFS，避免栈溢出”。

你已经比很多初学者走得更远了！加油 💪

DFS 和 BFS 是图和树遍历中最基础、最重要的两种搜索策略，它们的全称如下：

---

### ✅ DFS：**Depth-First Search**  
中文：**深度优先搜索**

- **特点**：一条路走到黑，走到叶子（或无法继续）再回退（回溯）。
- **类比**：像走迷宫时，一直沿着一条路往前走，直到撞墙，再回头换另一条路。
- **实现方式**：通常用 **递归** 或 **栈（Stack）** 实现。
- **在本题中的应用**：递归计算左右子树深度，就是 DFS。

---

### ✅ BFS：**Breadth-First Search**  
中文：**广度优先搜索**（也叫**宽度优先搜索**）

- **特点**：一层一层地遍历，先访问离起点近的节点。
- **类比**：往水中扔石头，水波一圈一圈向外扩散——先处理第1层，再第2层，再第3层……
- **实现方式**：通常用 **队列（Queue）** 实现。
- **在本题中的应用**：用队列逐层处理节点，每层深度 +1，就是 BFS。

---

### 🆚 简单对比记忆：

| 缩写 | 全称                     | 中文           | 数据结构 | 遍历顺序       |
|------|--------------------------|----------------|----------|----------------|
| DFS  | Depth-First Search       | 深度优先搜索   | 栈（递归）| 先深入，再横向 |
| BFS  | Breadth-First Search     | 广度优先搜索   | 队列     | 一层一层往外扩 |

---

💡 **小技巧记全称**：
- **Depth** → “深” → 往下钻 → DFS
- **Breadth** → “宽” → 横向铺开 → BFS

这两个术语在算法、面试、AI（如路径规划）中无处不在，掌握它们非常重要！