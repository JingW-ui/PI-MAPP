## 题目
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的 字母异位词。
## 解法1
```python
from collections import Counter
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return Counter(s) == Counter(t)
        
```
## 解法2
```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        l = [0]*26
        for char in s:
            index = ord(char) - ord('a')
            l[index] +=1
        for char in t:
            index = ord(char) - ord('a')
            l[index] -=1
            if l[index]<0:
                return False
        return all(c==0 for c in l)
```
## 解法3
```python
def is_anagram_unicode(s, t):
    """
    处理任意Unicode字符的通用解法
    """
    if len(s) != len(t):
        return False
    
    from collections import defaultdict
    
    count = defaultdict(int)
    
    # 统计s的字符频率
    for char in s:
        count[char] += 1
    
    # 减去t的字符频率
    for char in t:
        count[char] -= 1
        if count[char] < 0:
            return False
    
    # 检查是否所有计数都为0
    return sum(count.values()) == 0
```
## 经验总结
那这样写
count = {}
和这样写的区别是什么
from collections import defaultdict
count = defaultdict(int)

两种写法都能把「字符 → 出现次数」的映射建起来，但**使用体验和背后机制**有三点区别：

1. 读取不存在的键  
   - `count = {}`  
     必须 `count.get(ch, 0)` 或先 `if ch in count` 再读，否则 `KeyError`。  
   - `defaultdict(int)`  
     第一次访问 `count[ch]` 时自动调用 `int()`（返回 0），永远不会抛 KeyError，代码更短：

```python
count[ch] += 1   # 直接用即可
```

2. 内存与速度  
   对 26 个小写字母这种超小集合，差距可以忽略；  
   在 CPython 实现里，`defaultdict` 比内置 `dict` 多一次 C 层函数指针跳转，理论上**极微量**慢一点，但通常不必纠结。

3. 最后「归零检查」  
   - 用 `{}` 需要手动 `return all(v == 0 for v in count.values())` 或 `not count`。  
   - 用 `defaultdict` 同理；不过因为它会把访问过的键都留下，遍历长度一样。

一句话总结：  
**功能等价，defaultdict 写起来更省事，省掉 get/判断；普通 dict 则需要你显式处理“键不存在”的情况。**