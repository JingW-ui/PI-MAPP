## 题目
给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

## 解答1
```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        l1, l2 = len(s), len(t)
        if l1 == 0:
            return True  # 空字符串是任意字符串的子序列
        if l1 > l2:
            return False
        
        index = 0
        for char in s:
            index = self.get_index(char, t, index)
            if index == -1:
                return False
        return True

    def get_index(self, char: str, t: str, start: int) -> int:
        """从 t 的 start 位置开始查找 char，返回下一个起始位置（即匹配位置+1），未找到返回 -1"""
        for i in range(start, len(t)):
            if t[i] == char:
                return i + 1
        return -1

```

## 解答2 
```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        i = 0  # 指向 s 的指针
        j = 0  # 指指向 t 的指针
        
        while i < len(s) and j < len(t):
            if s[i] == t[j]:
                i += 1  # 匹配成功，s 向前
            j += 1      # t 总是向前
        
        return i == len(s)  # 如果 s 全部匹配完，说明是子序列
```
### 那这道题还有没有更高级的写法 面试的时候一般怎么写？
非常好的问题！在面试中，**“判断子序列”** 是一道经典题（LeetCode #392），考察点不仅是正确性，还包括 **代码简洁性、边界处理、扩展思维**。

---

## ✅ 面试中最推荐的写法：**双指针（Two Pointers）**

这是 **最优解**，也是面试官最期待看到的写法：

```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        i = j = 0
        while i < len(s) and j < len(t):
            if s[i] == t[j]:
                i += 1
            j += 1
        return i == len(s)
```

### ✨ 为什么这是面试首选？
- **时间复杂度 O(n)**，空间 O(1)
- **代码极简**（5 行核心逻辑）
- **清晰体现“顺序匹配”思想**
- **天然处理所有边界**（空字符串、s 比 t 长等）
- **易于扩展**（比如后面问“多个 s 查询同一个 t”）

> 💬 面试时你可以说：  
> “我用双指针，`i` 遍历 `s`，`j` 遍历 `t`。每当字符匹配，`i` 前进；无论是否匹配，`j` 都前进。最后看 `s` 是否走完。”

---

## 🚀 进阶写法（展示深度）：**迭代器 + all()（Python 特色）**

如果你面的是 **Python 岗**，可以用更 Pythonic 的写法惊艳面试官：

```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        t_iter = iter(t)
        return all(c in t_iter for c in s)
```

### 🔍 原理解释：
- `iter(t)` 创建一个**迭代器**，只能向前走。
- `c in t_iter` 会**消耗迭代器**，直到找到 `c` 或耗尽。
- `all(...)` 保证每个 `c` 都能按顺序在剩余 `t` 中找到。

### ✅ 优点：
- 代码只有 **2 行**
- 充分利用 Python 迭代器特性
- 时间复杂度仍是 O(len(t))

### ⚠️ 注意：
- 要能解释清楚 `c in t_iter` 的行为（很多候选人写出来但讲不清原理）
- 不适用于其他语言（属于 Python 技巧）

> 💬 面试时你可以说：  
> “这里我用了 Python 的迭代器惰性求值特性。`c in t_iter` 会从上次停止的位置继续查找，天然保证了顺序，非常契合子序列的定义。”

---

## 🧠 如果面试官追问：“如果有大量 s 要查同一个 t 呢？”

这时候就要上 **预处理 + 二分查找** 的高级解法！

### 思路：
1. 预处理 `t`，建立字符 → 所有出现位置的映射（如 `'a': [0, 5, 10]`）
2. 对每个 `s`，用二分查找快速定位下一个合法位置

```python
from collections import defaultdict
import bisect

class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        # 预处理 t（通常放在类初始化里，如果多次调用）
        char_positions = defaultdict(list)
        for i, char in enumerate(t):
            char_positions[char].append(i)
        
        # 查找 s
        curr_pos = -1
        for char in s:
            if char not in char_positions:
                return False
            # 在 char_positions[char] 中找第一个 > curr_pos 的位置
            idx = bisect.bisect_right(char_positions[char], curr_pos)
            if idx == len(char_positions[char]):
                return False
            curr_pos = char_positions[char][idx]
        return True
```

### ⏱ 复杂度：
- 预处理：O(len(t))
- 单次查询：O(len(s) × log(len(t)))
- 适合 **多次查询** 场景（比如 10000 个 s 查同一个 t）

> 💬 面试时你可以说：  
> “如果要支持高频查询，我会对 `t` 建立索引，用二分查找加速每次匹配。虽然单次查询稍慢，但均摊成本更低。”

---

## 📌 总结：面试怎么答？

| 场景 | 推荐写法 | 目的 |
|------|--------|------|
| **常规面试** | 双指针 | 展示基础扎实、代码简洁 |
| **Python 岗 / 想秀技巧** | `iter + all` | 展示语言熟练度 |
| **追问“大量查询”** | 预处理 + 二分 | 展示系统设计和优化思维 |

> ✅ **最佳策略**：先写双指针（确保正确），然后说：“其实还有更 Pythonic 的写法……”，再补充迭代器版本。如果时间允许可提一句“若需高频查询，可用二分优化”。

这样既稳又亮眼！